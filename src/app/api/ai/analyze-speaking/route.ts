import { NextResponse } from 'next/server';
import { GrokClient } from '@/infrastructure/api/grok';
import { SpeakingRepository } from '@/infrastructure/repositories/SpeakingRepository';
import { createArchive, checkDuplicate } from "@/infrastructure/firebase/archive-repository";

const TIMEOUT_MS = 30000;

function getModel() {
  return process.env.GROK_MODEL?.trim() || "grok-4-fast-non-reasoning";
}

// Helper to parse JSON safely
function safeParse(text: string) {
    try {
        // Remove code fences if present
        const cleaned = text.replace(/```json/g, '').replace(/```/g, '').trim();
        return JSON.parse(cleaned);
    } catch {
        return null;
    }
}

async function getClient() {
  const key = process.env.GROK_API_KEY;
  if (!key) return null;
  return new GrokClient(key, process.env.GROK_BASE_URL);
}

function buildPrompt(text: string, language: string, uiLanguage: string = 'en') {
    return `You are a helpful language tutor. 
    Analyze the spoken sentence: "${text}"
    Target Language: ${language}
    UI Language (for explanations): ${uiLanguage}

    Return JSON format only:
    {
      "improved": "Better/Natural version in target language (or same if good)",
      "grammarNotes": ["Grammar point 1 in UI language", "Grammar point 2 in UI language"],
      "rootMeaningGuide": {
        "word_in_target": "Root meaning/Image explanation in UI language"
      }
    }
    
    Rules:
    - "improved" must be in target language.
    - "grammarNotes" must be in UI language.
    - "rootMeaningGuide" keys are key words from the sentence, values are explanations in UI language focusing on core 'root' image/meaning.
    - If the sentence is perfect, "improved" = original.
    - Provide 1-3 grammar notes if any issues, or just good points.
    `;
}

export async function POST(req: Request) {
  try {
    const { text, language, userId } = await req.json();

    if (!text || !userId) {
      return NextResponse.json({ error: 'Missing required fields' }, { status: 400 });
    }

    // 1. Save Session (Initial)
    const session = await SpeakingRepository.saveSession({
        id: '', // Generated by repo
        userId,
        language,
        transcript: text,
        durationSec: 0, 
        aiAnalyzed: false,
    });

    // 2. Call Grok
    const client = await getClient();
    if (!client) {
         return NextResponse.json({ 
             feedback: mockFeedback(text, session.id, userId),
             session 
         }, { status: 200 }); // Return mock if no key
    }

    const controller = new AbortController();
    const timer = setTimeout(() => controller.abort(), TIMEOUT_MS);

    try {
        const completion = await client.chatCompletion({
            messages: [
                { role: "system", content: "You are a helpful language tutor. Respond in JSON." },
                { role: "user", content: buildPrompt(text, language) } // Simplified UI language for MVP
            ],
            model: getModel(),
            temperature: 0.3,
            signal: controller.signal,
            response_format: { type: "json_object" } 
        });
        
        const parsed = safeParse(completion as any); 
        
        let feedbackData = parsed;
        if (!parsed) {
            console.error("Failed to parse Grok response", completion);
            feedbackData = mockFeedback(text, session.id, userId);
        }

        // 3. Save Feedback
        const feedback = await SpeakingRepository.saveFeedback({
            sessionId: session.id,
            userId,
            original: text,
            improved: feedbackData.improved || text,
            grammarNotes: feedbackData.grammarNotes || [],
            rootMeaningGuide: feedbackData.rootMeaningGuide || {}
        });

        // 4. Save to Learning Archive (Auto)
        if (feedbackData.rootMeaningGuide) {
            const archivePromises = Object.entries(feedbackData.rootMeaningGuide).map(async ([word, meaning]) => {
                const title = word;
                const rootMeaning = meaning as string;
                
                // Check duplicate by title (word)
                const isDup = await checkDuplicate(userId, title);
                
                if (!isDup) {
                    await createArchive({
                        userId,
                        type: 'word', 
                        title,
                        rootMeaning,
                        examples: [], 
                        sourceId: session.id,
                        sourceType: 'speaking',
                        sourceText: text,
                        memorized: false,
                        correctCount: 0
                    });
                }
            });
            
            // Wait for archives to be saved (or fire and forget if performance is critical, but safer to await)
            await Promise.all(archivePromises);
        }

        return NextResponse.json({ feedback, session });

    } catch (e) {
        console.error("Grok call failed", e);
        // Fallback
        return NextResponse.json({ 
             feedback: mockFeedback(text, session.id, userId),
             session 
         }, { status: 200 });
    } finally {
        clearTimeout(timer);
    }

  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

function mockFeedback(original: string, sessionId: string, userId: string) {
    return {
        id: 'mock-feedback',
        sessionId,
        userId,
        original,
        improved: original + " (improved)",
        grammarNotes: ["This is a mock grammar note.", "Please configure Grok API Key."],
        rootMeaningGuide: { "mock": "This is a mock root meaning." },
        createdAt: new Date()
    };
}
